/**
 * @class rune::Shader
 * @brief A shader that can be used to render objects to the screen.
 * 
 * @author Thomas Montano
 * @date April 25 2020
 * 
 */

#ifndef SHADER_H_DEFINED
#define SHADER_H_DEFINED

#include "core.h"
#include <fstream>
#include <string>
#include <sstream>
#include "renderWindow.h"
#include <unordered_map>

namespace rune{

///Compilable GLSL code generated by the shader file.
struct RUNE_ENGINE ShaderProgramSource
{ 
  ///The vertex shader code to be compiled.
  std::string VertexSource;

  ///The fragment shader code to be compiled.
  std::string FragmentSource;
  /**
   * \param vertex The code to be used for the vertex shader.
   * \param frag The code to be used for the fragment shader.
   */
  ShaderProgramSource(std::string const& vertex, std::string const& frag) : VertexSource(vertex), FragmentSource(frag)
  {
  }

};

class RUNE_ENGINE Shader
{

private:
  //Shader id to be used for binding the shader during rendering
  unsigned int m_shaderID;
  //Compile and set the shader up given string literals.
  unsigned int CreateShader(std::string const& vertexShader, std::string const& fragmentShader);
  //Create the shader into a compiled shader id for opengl
  unsigned int CompileShader(unsigned int type, const std::string& source);
  //Parse a raw string containing glsl source code and turn it into a ShaderProgramSource
  ShaderProgramSource ParseShader(std::string const& sourceCode);

  std::unordered_map<std::string, int> m_UniformLocationCache;

  ///Retrieve the location of the uniform in the GPU
  int getUniformLocation(std::string const&  name);

public:
  ///Default empty constructor.
  Shader();

  ///Default constructor to create and load a shader.
  Shader(const std::string& filePath);
  ///Constructor that will compile a character array into a shader.
  Shader(const char* sourceCode);
  ///Create a shader from a rune::ShaderProgramSource
  Shader(ShaderProgramSource);
  ///This is the base function that the different constructors call.
  void makeNewShader(std::string const& filePath);

  ///Configure the shader to be active on the GPU, must be done before drawing something.
  void bind(void);

  int getShaderID();
  void setShader(int shaderID);
  
  ///Set a float shader uniform.
  void setUniform1f(std::string const& name, float value);
  //Set a vec2 shader uniform
  void setUniform2f(std::string const& name, float v0, float v1);
  void setUniform3f(std::string const& name, float v0, float v1, float v2);
  ///Set a vec4 shader uniform.
  void setUniform4f(std::string const& name, float v0, float v1, float v2, float v3);
  ///Set an integer shader uniform.
  void setUniform1i(std::string const& name, int value);
  
};
}

#endif

/**
 * 
 * @page shaders Shaders
 * 
 * Make sure your vertex and fragment shaders are declared in the same file. The function will separate them for you.
 * Write up a vertex and fragment shader with the header #shader vertex or #shader fragment. The example code below details how this should be done.
 * 
 * You should then load this into a drawable component by first declaring a shader and then setting your GLSL code as active.
 * 
 * @code
 * 
 * rune::Shader mySprite;
 * 
 * mySprite.changeShader("path to your shader");
 * 
 * @endcode
 *
 * @section vertex Vertex Shader
 * 
 * This will set up a new vertex and fragment shader to be used by the sprite object.
 * 
 * @code
 * 
 *#shader vertex
 *#version 330 core

  layout(location = 0) in vec2 aPos;
  layout(location = 1) in vec4 aColor;
  layout(location = 2) in vec2 aTexCoord;

  uniform vec2 cameraPos = vec2(0, 0);
  uniform float cameraZoom = 1;
  uniform float rotation = 0;
  uniform vec2 origin = vec2(0,0);
  uniform float aspectRatio = 1;

  out vec4 ourColor;
  out vec2 TexCoord;

  void main()
  {

    vec2 vertices = cameraZoom*aPos - cameraPos;

    if(rotation != 0)
    {
      float angle = radians(rotation);
      mat2 rotationMatrix = mat2(cos(angle), aspectRatio*sin(angle), -sin(angle)/aspectRatio, cos(angle));

      vertices = vertices - (cameraZoom*origin - cameraPos);
      vertices = rotationMatrix * vertices;
      vertices = vertices + (cameraZoom*origin - cameraPos);
    }

    ourColor = aColor;
    gl_Position = vec4(vertices,0,1);

    TexCoord = aTexCoord;

  }
    
    @endcode

    @section fragment Fragment Shader

    @code

    #shader fragment
    #version 330 core

    out vec4 FragColor;

    in vec4 ourColor;
    in vec2 TexCoord;

    uniform sampler2D ourTexture;

    void main()
    {
      FragColor = texture(ourTexture, TexCoord) * ourColor;
    }
 * 
 * @endcode
 * 
 */